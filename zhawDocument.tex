%%	build-queue:
%%	
%%	¦¦¦ very first run. No .ist files yet
%%	¦¦	index, citation/bibliography or glossary changed
%%	¦	every change apart from the above mentioned. Double run for labels and toc.
%%	
%%	¦¦¦xelatex
%%	¦¦makeglossaries
%%	¦¦makeindex
%%	¦¦bibtex
%%	¦xelatex
%%	¦xelatex
%%	

\RequirePackage[l2tabu,orthodox]{nag}
\documentclass[10pt,a4paper,titlepage,twoside,english,final]{zhawreprt}

\include{packages}
\if false
\include{glossaryentries}
\fi

\include{zhawSetup}

\begin{document}

\maketitle

\chapter*{Abstract}\label{sec:Abstract}
\notes{\item Zusammenfassung}


\chapter*{Preface}\label{sec:Preface}
\notes{\item Stellt den persönlichen Bezug zur Arbeit dar und spricht Dank aus.}
The \gls{SSH} protocol \citep{rfc253,rfc6668,rfc8268,rfc8308,rfc8332} is a system that allows a user to log in on a remote machine and perform tasks on that remote machine via a \gls{CLI}. \gls{SSH} is widely known and used in everyday tasks. However: It is now over twelve years old in its current form. One of the problems with \gls{SSH} is its complexity, both in the initial phase when key material is exchanged, but also later, for example because the server must always decide whether to return a character that has been sent to it or not (echo).

The goal of this work is a radically simplified protocol, which in its functions is similar to \gls{SSH} (N.B. the similarity concerns the functions, not necessarily the protocol details). I develop the protocol, as well as a client and a server - all in \gls{Go}. I demonstrate that the software can replace \gls{SSH} by showing that it can handle several common use cases, among them:

\begin{itemize}
\item Interactive session
\item \texttt{Rsync} with my solution as transport protocol
\end{itemize}

This bachelor thesis was proposed by Dr. Stephan Neuhaus \citep{BA19_neut_03} and aroused my interest as it is a challenge in the domain of information security and will produce a palpable result.

On this note I would like to thank \gls{ZHAW} for granting me the opportunity to do my Bachelors thesis here and Dr. Stephan Neuhaus for helping me along the way of this Bachelors thesis.

As an additional remark, I would like to point out that the team for this Bachelors thesis originally consisted of two people, but after some months of uncertainty, Mr Schwarz decided to opt out of the project as he said he underestimated the workload from the modules he booked on top of the Bachelors thesis. This happened halfway through the project and had great impact on the project itself. The rest of this project was finished by me, Raphael Emberger.

\makedeclarationoforiginality

\tableofcontents

\chapter{Introduction}\label{chp:Introduction}
\section{Initial Position}\label{sec:InitialPosition}
\notes{
\item Nennt bestehende Arbeiten/Literatur zum Thema -> Literaturrecherche
\item Stand der Technik: Bisherige Lösungen des Problems und deren Grenzen
\item (Nennt kurz den Industriepartner und/oder weitere Kooperationspartner und dessen/deren Interesse am Thema Fragestellung)
}
There was no thesis done on this subject that could have been used as reference. There are however several software projects that deal with a similar problem.

\subsection{OpenSSH}\label{ssec:OpenSSH}
The most noteworthy work to mention is of course \gls{SSH} itself. \cite{openssh} is the name of the open source project which provides millions of administrators and developers with the ability to securely connect to a remote host. It replaces the up until then widely used protocols like \cite{telnet}(see \ref{ssec:Telnet}) and \cite{rlogin}/\cite{rsh}(see \ref{ssec:BerkeleyRCommands}).\\
\gls{SSH} uses \gls{TLS} to secure the communication channel between two peers and has earned itself a spot on the low end of the \gls{port} table: It occupies \gls{port} 22.\\
\gls{SSH}s features can be used very flexibly: After it builds up a secure connection between a client and a server, it can be used to remotely login and use a \gls{terminal} on that machine.
It can also forward traffic on local ports to the remote host through the secure channel. This is also used by third party programs such as \cite{rsync}.\\
When it comes to the log in procedure itself, \gls{SSH} allows for standard user log in using the \gls{API} of the \glspl{PAM}. Another feature is whitelisting of clients via their public keys, which barres intrusion via hijacked user-password-credentials.\\
After a secure connection could be established, there are multiple possibilities to use the opened channel. One is to forward the \gls{GUI} of a remote program to the client. Another one is to use this channel to tunnel more connections through it: For example can the traffic of an application which uses a specific \gls{port} be forwarded to the remote host. This can obscure and secure this traffic between the host and the server.

\subsection{Telnet}\label{ssec:Telnet}
Telnet\citep{rfc15,rfc854} is an old(1969) and deprecated communication protocol which doesn't feature any security. However, in other implementations, \gls{TELNETS} was proposed, which features encryption over the communication channel.\\
Telnet still has 23 as its very own \gls{port} assigned to it.
\subsubsection{Go-Telnet}
Go-Telnet\citep{gotelnet} is a \gls{TELNETS} supporting client-server-application which has been implemented in \gls{Go}.

\subsection{Berkeley r-commands}\label{ssec:BerkeleyRCommands}
The Berkley r-commands are a set of commands to do certain tasks on remote hosts. Those tasks are similar to their counterparts without a leading "\texttt{r}".
\begin{itemize}
\item \cite{rlogin}\\
This command connects to the host and performs a \cite{login} command, which includes authentication and if successful, spawning a user \gls{shell}.
\item \cite{rsh}\\
\texttt{rsh} spawns a \gls{shell} without the log in process.
\item \cite{rexec}\\
With this command, the user can log in to a remote machine and execute one command.
\item \cite{rcp}\\
Using this command gives the user the ability to copy from and to a remote host.
\item \cite{rwho}\\
This command tells the user what users are currently logged in on the remote machine.
\item \cite{rstat}\\
\texttt{rstat} displays file system information from remote hosts.
\item \cite{ruptime}\\
With this command, the user can see the uptime, number of logged in users and current work load of the remote machine.
\end{itemize}


\section{Task}\label{sec:Task}
\notes{
\item Formuliert das Ziel der Arbeit
\item Verweist auf die offizielle Aufgabenstellung des/der Dozierenden im Anhang
\item (Pflichtenheft, Spezifikation)
\item (Spezifiziert die Anforderungen an das Resultat der Arbeit)
\item (Übersicht über die Arbeit: stellt die folgenden Teile der Arbeit kurz vor)
\item (Angaben zum Zielpublikum: nennt das für die Arbeit vorausgesetzte Wissen)
\item (Terminologie: Definiert die in der Arbeit verwendeten Begriffe)
}
The official formulation of the tasks can be found in the appendix \ref{ssec:OfficialStatementOfTasks}.\\
The objective of this thesis is as follows:
\begin{itemize}
\item Design and implementation of a client-server protocol that can manage interactive sessions.
\item Design and implementation of a privilege-separation architecture on the server side that allows safe dropping of privileges once a client establishes a connection.
\end{itemize}

For a passing grade (4.0), the work must contain at least the following:
\begin{itemize}
\item In the thesis, an introduction to the problem and why the envisaged solution will solve it.
\item In the thesis, a survey of related work in the area.
\item In the thesis, a detailed design of the solution.
\item In the thesis, an evaluation of the performance of the implemented solution.
\item In the software, a privilege-separation architecture.
\end{itemize}

Incorporating the following components will improve the grade:
\begin{itemize}
\item In the related work section of the thesis, a comparison of all the related work with the envisaged solution, outlining why the envisaged solution is better.
\item In the thesis, a detailed analysis of the security of the solution, including possible attacks and defenses.
\item Use of \gls{TLS} as the transport layer.
\item A proof-of-concept client that can handle interactive sessions.
\item A proof-of-concept client that works as a transport for \texttt{rsync}.
\end{itemize}

\vspace{1.5cm}
This thesis has been worded with technically literate readers in mind. However: For core concepts and special terms, a glossary can be found at \ref{sec:Glossary}. Used acronyms are listed in \ref{sec:AcronymGlossary}.

\chapter{Design}\label{chp:Design}
\section{Implementation Language}\label{sec:DesignImplementationLanguage}
In the beginning of the project, Dr Neuhaus suggested the use of \gls{Go} as a modern low-level language over interpreted languages for considerations of security. He emphasized that the use of other low-level languages(like \gls{C} or \gls{C++}) was permissible. In the end the project was implemented in \gls{Go} as suggested.\\
However, this lead to a few problems in the implementation process(See \ref{sec:Problems}).

\section{Secure Connection}\label{sec:DesignSecureConnection}
When building an application that communicates via the network, certain security measures are mandatory to ensure a secure communication. If such measures are not taken, the communication between the client and the server can be fully read and even altered by a third party. To prevent this, the communication can be encrypted with \gls{TLS}(originally known as \gls{SSL}). Today's state-of-the-art is \gls{TLS} 1.3\citep{rfc8446}.\\
When connecting, the client checks the server \gls{X.509}-certificate of the server to authenticate the peer. Optionally, the client can also authenticate himself to the server. After this, the two start an encrypted channel by for example using the \gls{DiffieHellmanKX} or letting the server decrypt a random secret that has been encrypted with the servers public key. After this, every message can be transferred between client and server in an encrypted way.\\
Explanations about the implementation can be found in \ref{sec:ImplSecureConnection}.

\section{Authentication via PAM}\label{sec:DesignAuthViaPAM}
For authentication of users on Linux systems, \gls{PAM} exists. I provides a clean separation between a program and the sensitive part of authentication. \gls{PAM} operates using transactions, which represent a link to a \gls{PAM} context. Using this transaction, an application can do various actions regarding account management, authentication or session management. To initialize such a context and transaction, an application has to call the \cite{pam_start} function.
\setlistingC
\begin{lstlisting}[caption={Initializing a \gls{PAM} context},label=lst:InitPAMContext]
#include <security/pam_appl.h>

struct pam_message {
    int msg_style;
    const char *msg;
};

struct pam_response {
    char *resp;
    int resp_retcode;
};

struct pam_conv {
    int (*conv)(int num_msg, const struct pam_message **msg,
                struct pam_response **resp, void *appdata_ptr);
    void *appdata_ptr;
};
int pam_start(const char *service_name, const char *user, const struct pam_conv *pam_conversation, pam_handle_t **pamh);
\end{lstlisting}

Similarly, the created context has to be terminated with \cite{pam_end}
\setlistingC
\begin{lstlisting}[caption={Terminating a \gls{PAM} context},label=lst:TermPAMContext]
#include <security/pam_appl.h>

int pam_end(pam_handle_t *pamh, int pam_status);
\end{lstlisting}

After creating a context, the application can prepare the transaction with \cite{pam_set_item} and \cite{pam_get_item}. Using those function, fields like \texttt{PAM\_RUSER} and \texttt{PAM\_RHOST}, which together(\texttt{PAM\_RUSER@PAM\_RHOST}) represent the requesting user(remote or local). If in any of the prior or later steps any errors occur, the corresponding error message can be received with \cite{pam_strerror}.
\setlistingC
\begin{lstlisting}[caption={\gls{PAM} functions},label=lst:PAMFunctions]
#include <security/pam_appl.h>

int pam_get_item(const pam_handle_t *pamh, int item_type, const void **item);
int pam_set_item(pam_handle_t *pamh, int item_type, const void *item);
const char *pam_strerror(pam_handle_t *pamh, int errnum);
\end{lstlisting}

Now that the transaction has been appropriately prepared, the application can request to authenticate a user via \cite{pam_authenticate}:
\setlistingC
\begin{lstlisting}[caption={\gls{PAM} authentication},label=lst:PAMAuthentication]
#include <security/pam_appl.h>

int pam_authenticate(pam_handle_t *pamh, int flags);
\end{lstlisting}

Now \gls{PAM} uses the \texttt{pam\_conv} struct given in \cite{pam_start} that points to a function to interactively ask the application to authenticate the user. The application can then ask the user for the user name if not provided already and the password. After successful authentication, the function returns \texttt{PAM\_SUCCESS} and the application should call \cite{pam_setcred} to establish and maintain the credentials of the logged in user.
\setlistingC
\begin{lstlisting}[caption={\gls{PAM} credential setting},label=lst:PAMCredSet]
#include <security/pam_appl.h>

int pam_setcred(pam_handle_t *pamh, int flags);
\end{lstlisting}

Now the application can do other \gls{PAM} related actions like session management(see \ref{ssec:DesignLoginAccountingWithPAM}). To finish, the application terminates the context properly and all associated memory gets invalidated.\\
The implementation differs from this approach slightly. See \ref{sec:ImplAuthViaPAM}.

\section{Authentication via Keys}\label{sec:DesignAuthViaKeys}
A user can also authenticate himself without a password but instead using public key cryptography. For this, a user has to create a key pair consisting of a private and a public key. Before the actual authentication, a hashed version of the public key has to be stored on the server.\\
When starting an authentication, the user sends his public key to the server, which compares its hash with the stored keys that are deemed permissible for authentication. If it matches, the server encrypts a random secret(with high entropy) with the public key to the user. The user decrypts the message with his private key and sends it back to the server. If the returned secret matches the original secret, the user proved that he is the legitimate owner of the public key.\\
This authentication is sufficiently secure from third parties which do not have access to the private key of the user, as it can prove the authenticity of a user.\\
The implementation of this feature also differs from the original design, as can be read in \ref{sec:ImplAuthViaKeys}).

\section{User Data Querying}\label{sec:DesignUserDataQuerying}
To spawn the default \gls{shell} of a user, the path to said \gls{shell} is required. This and other information can be found inside the \texttt{/etc/passwd} file. The file holds information about a users login-\gls{shell}, password hash, groups, user information, \gls{UID}, \gls{GID} and home directory. to spawn a \gls{shell}, the first and the last of these pieces of information are substantial to successfully login a user. To query such data, \gls{Unix} offers \cite{getpw}, which doesn't just read the \texttt{passwd} file, but also draws information about users from other sources, if they exist. This has been used in the implementaion phase(see \ref{sec:ImplUserDataQuerying}):
\setlistingC
\begin{lstlisting}[caption={Definition of passwd and {\cite{getpw}}},label=lst:PasswdDefinition]
#include <sys/types.h>
#include <pwd.h>

struct passwd {
	char   *pw_name;       /* username */
	char   *pw_passwd;     /* user password */
	uid_t   pw_uid;        /* user ID */
	gid_t   pw_gid;        /* group ID */
	char   *pw_gecos;      /* user information */
	char   *pw_dir;        /* home directory */
	char   *pw_shell;      /* shell program */
};

struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
\end{lstlisting}

\section{Login Accounting}\label{sec:DesignLoginAccounting}
When a user logs into a \gls{Unix} machine, a session and a timestamp gets created.\\
For this, the two files \texttt{/var/run/utmp} and \texttt{/var/log/wtmp} provide the appropriate storage. The \texttt{utmpx} \gls{API} offers appropriate functions. The \texttt{utmpx} struct represents a single entry in those files:
\setlistingC
\begin{lstlisting}[caption={Definition of the utmpx structure {\citep[p.819]{KerriskTLPI}}},label=lst:UtmpxDefinition]
#define _GNU_SOURCE
/* Without _GNU_SOURCE the two field names below are prepended by "__" */
struct exit_status {
	short e_termination; /* Process termination status (signal) */
	short e_exit; 		 /* Process exit status */
};
#define __UT_LINESIZE 32
#define __UT_NAMESIZE 32
#define __UT_HOSTSIZE 256
struct utmpx {
	short ut_type; 				 /* Type of record */
	pid_t ut_pid; 				 /* PID of login process */
	char ut_line[__UT_LINESIZE]; /* Terminal device name */
	char ut_id[4]; 				 /* Suffix from terminal name, or	ID field from inittab(5) */
	char ut_user[__UT_NAMESIZE]; /* Username */
	char ut_host[__UT_HOSTSIZE]; /* Hostname for remote login, or kernel version for run-level messages */
	struct exit_status ut_exit;  /* Exit status of process marked as DEAD_PROCESS (not filled in by init(8) on Linux) */
	long ut_session; 			 /* Session ID */
	struct timeval ut_tv; 		 /* Time when entry was made */
	int32_t ut_addr_v6[4]; 		 /* IP address of remote host (IPv4 address uses just ut_addr_v6[0], with other elements set to 0) */
	char __unused[20]; 			 /* Reserved for future use */
};
\end{lstlisting}

On login, a record has to be written to the \texttt{utmp} file to indicate that the user logged in. If there is already a record for the active \gls{terminal}, then the entry has to be updated, otherwise a new entry has to be appended. A call to \cite{pututxline} should suffice in performing these steps properly. The application has to set the \texttt{ut\_type} field of the \texttt{utmpx} struct to \texttt{USER\_PROCESS} to mark a user login.\\
Similarly to the \texttt{utmp} update after login, the application has to report to the \texttt{utmpx} \gls{API} that the session ended. This procedure consists of almost the same actions as the one after login, with exception of \texttt{ut\_user} being zeroed out and \texttt{ut\_type} being set to \texttt{DEAD\_PROCESS}\citep[p.828]{KerriskTLPI}.\\
A program can also query the \texttt{utmp} file with the according getters.
\setlistingC
\begin{lstlisting}[caption={\texttt{utmpx} \gls{API} functions},label=lst:UtmpxApiFunctions]
#include <utmp.h>

struct utmp *getutent(void);
struct utmp *getutid(const struct utmp *ut);
struct utmp *getutline(const struct utmp *ut);

struct utmp *pututline(const struct utmp *ut);
\end{lstlisting}

\subsection{Login Accounting with PAM}\label{ssec:DesignLoginAccountingWithPAM}
\gls{PAM} supports binding login accounting to its own session functions \cite{pam_open_session} and \cite{pam_close_session}:
\setlistingC
\begin{lstlisting}[caption={\gls{PAM} session management},label=lst:PAMSessionManagement]
#include <security/pam_appl.h>

int pam_open_session(pam_handle_t *pamh, int flags);
int pam_close_session(pam_handle_t *pamh, int flags);
\end{lstlisting}

\section{Terminal Mode}\label{sec:DesignTerminalMode}
The client expects to send all its input directly to the \gls{shell} without prior interpretation. To achieve this, the client-side \gls{terminal} has to be set from the default \texttt{cooked}- into the \texttt{raw}-mode\citep[p.1309]{KerriskTLPI}. This sends each key stroke to the server-side \gls{shell} as is. After the termination of the session, the original \texttt{cooked}-mode has to be restored to ensure operation as per usual.

\section{Pseudoterminal}\label{sec:DesignPseudoterminal}
\glspl{pty} are an \gls{IPC} mechanism that help solving the problem of how two remote programs can communicate as if they were directly connected via a \gls{terminal}(see figure \ref{fig:HowToOperateTtyOrientedProgramOverNetwork}).\\
A \gls{shell} expects to be connected to a full fledged \gls{tty}(or a \gls{tty} emulator). To check whether it is inside such an environment, it uses \cite{isatty} on the \gls{fd} it is connected to. Therefore the \gls{fd} it is connected to should behave like a real \gls{terminal}. This is where \glspl{pty} come into play.
\begin{figure}[ht]
\includegraphics[width=\textwidth]{PseudoterminalProblem}
\caption{How to operate a \gls{tty}-oriented program over a network?\citep[p.1376]{KerriskTLPI}}
\label{fig:HowToOperateTtyOrientedProgramOverNetwork}
\end{figure}
\begin{figure}[ht]
\includegraphics[width=\textwidth]{Pseudoterminal}
\caption{Two programs communicating via a \gls{pty}\citep[p.1377]{KerriskTLPI}}
\label{fig:TwoProgramsCommunicatingViaAPty}
\end{figure}
To do this, two files are created: The \gls{ptm} and the corresponding \gls{pts}(see figure \ref{fig:TwoProgramsCommunicatingViaAPty}). \gls{Linux} provides a \gls{pty} generator at \texttt{/dev/ptmx}, which creates a \gls{ptm} and a \gls{pts}. This works by simply opening the \texttt{/dev/ptmx} file using \cite{posix_openpt}. After this, a program has to grant the \gls{pts} file ownership and permissions with \cite{grantpt}, unlock it with \cite{unlockpt} and retrieve its file name with \cite{ptsname}:
\setlistingC
\begin{lstlisting}[caption={\gls{pty} related \gls{Linux} \gls{API} functions},label=lst:PtyFunctions]
#define _XOPEN_SOURCE 500
#include <stdlib.h>

int posix_openpt(int flags);
int grantpt(int fd);
int unlockpt(int fd);
char *ptsname(int fd);
\end{lstlisting}

With the \gls{pty} properly set up, a child bound to the \gls{pts} side will assume it is connected to a \gls{terminal} and also behave as such. This mechanism is key to running a \gls{shell} and forwarding all traffic between a remote client and the \gls{shell}. In case of \gls{SSH} and the objective of this thesis, the layout looks like in figure \ref{fig:HowSSHUsesPty}.
\begin{figure}[ht]
\includegraphics[width=\textwidth]{PseudoterminalSSH}
\caption{How \texttt{ssh} uses a \gls{pty}\citep[p.1378]{KerriskTLPI}}
\label{fig:HowSSHUsesPty}
\end{figure}

\newpage
\section{Flow of Action}\label{sec:DesignFlowOfAction}
To create a client-server protocol for remote log in and interactive sessions, a clear cut architecture is mandatory. The flow of a typical use case should look like this:

\begin{enumerate}
\item Server listens for incoming connection.
\item Client dials server.
\item Server spawns the users login \gls{shell} and forwards all traffic between \gls{shell} and Client.
\item Client uses \gls{shell} on remote machine.
\item Client terminates session.
\item Host terminates.
\end{enumerate}

However, there are multiple security concerns to be satiated:

\begin{enumerate}
\item The Client must authenticate itself for a user of the remote system with the appropriate credentials.
\item The Server has to drop privilege after a successful login to prevent privilege escalation.
\item The Server has to spawn the login \gls{shell} of the logged in user with the appropriate rights.
\end{enumerate}

Furthermore, the current design does not allow for multiple sessions to be run parallel. Therefore it was decided to spawn a new process to handle everything beginning after the connection has been established.\\
This lead to  the following general flow of actions:

\begin{enumerate}
\item Server listens for incoming connection.
\item Client dials server.
\item Server spawns a Host upon established connection.
\item Host sets up connection.
\item Host asks Client to authenticate himself.
\item Client authenticates himself.
\item Host drops privilege to logged in user.
\item Host spawns the users login \gls{shell} with the same credentials and forwards all traffic between \gls{shell} and Client.
\item Client uses \gls{shell} on remote machine.
\item Client terminates session.
\item Host terminates.
\end{enumerate}

\newpage
\subsection{Old Design}\label{ssec:OldDesign}
An earlier draft of the flow of actions was designed as a sequence diagram and can be seen in figure \ref{fig:SeqDiaOriginal}.
\begin{figure}[ht]
\includegraphics[width=\textwidth]{SequenceDiagram}
\caption{Sequence diagram draft.}
\label{fig:SeqDiaOriginal}
\end{figure}

This design used a \gls{Request Broker}, which would put another master-slave-relationship between a \gls{shell} and the \gls{Request Broker}. This would have been an over-complication of the use of a \gls{shell}, which, if set correctly, already runs only with the rights of the corresponding user and its groups.

\subsection{New Design}\label{ssec:NewDesign}
The new and current design of the architecture can be seen in figure \ref{fig:SeqDiaCurrent}.
\begin{figure}[ht]
\includegraphics[width=\textwidth]{SequenceDiagramNew}
\caption{Sequence diagram of current implementation.}
\label{fig:SeqDiaCurrent}
\end{figure}

This new design of the \texttt{goshd} server calls the external binary \texttt{goshh} from the server process and lets it handle the connection itself. The server then asks for some environment variables from the client. Then the server tries to figure out whether the client can authenticate himself via keys. If authentication with keys is a viable option, it performs the key authentication according to \ref{sec:DesignAuthViaKeys}. If it succeeds, it notifies the client of the authentication result. The host then spawns the user's \gls{shell} and forwards the traffic between the two.\\
If key authentication does not succeed, the host performs the classical authentication with user-password-credentials which also ends in spawning a user \gls{shell} if successful.\\
If the \gls{shell} exits or the host process receives an \gls{SIGINT}, it cleans up behind the exited \gls{shell} and exits as well.\\
The client performs the transfer of the environment variables until it receives the termination packet. Upon arrival of said packet, it prepares for the forwarding of the traffic between the user and the server. It does so by setting the \gls{terminal} in raw-mode and waits until the connections dies(it receives \texttt{EOF}) and then restores the \gls{terminal} to the default cooked state.


\chapter{Implementation}\label{chp:Implementation}
\section{Secure Connection}\label{sec:ImplSecureConnection}
As described in \ref{sec:DesignSecureConnection}, \gls{TLS} was used to secure the connection between the client and the server. For this, the \gls{Go}-package \texttt{crypto/tls} has been used. This package requires both client and server to extend the \texttt{GODEBUG} variable with a flag to activate support for \gls{TLS} 1.3:
\setlistingGo
\begin{lstlisting}[caption={Activating \gls{TLS} 1.3 in \gls{Go}},label=lst:TlsInGo]
func init() {
    os.Setenv("GODEBUG", os.Getenv("GODEBUG")+",tls13=1")
}
\end{lstlisting}
The server-side of the solution has to have a certificate, which has to be generated newly when actually installing the solution on a machine. For testing purposes, a self-signed certificate was created using \cite{openssl}:
\setlistingBash
\begin{lstlisting}[caption={Generating a self-signed certificate and private key},label=lst:GenCertNKey]
openssl req -newkey rsa:2048 -nodes -keyout key.pem -x509 -days 365 -out certificate.pem
\end{lstlisting}
The files \texttt{key.pem} and \texttt{certificate.pem} can be found inside the \texttt{test} folder in the project's root folder.\\
The current implementation is set to skip verification of insecure certificates. Handling such a case has been decided to be handled in future improvements.

\section{Authentication via PAM}\label{sec:ImplAuthViaPAM}
There are no official packages in \gls{Go} that provide a wrapper to \gls{PAM}(refer to \ref{sec:DesignAuthViaPAM}). In earlier stages of the project, a wrapper from \cite{gopam} has been used. However, it was deemed more sensible to rely on \cite{login}, as this already covers login-accounting and other post-login actions(see \ref{sec:DesignLoginAccounting} and \ref{ssec:DesignLoginAccountingWithPAM}).

\section{Authentication via Keys}\label{sec:ImplAuthViaKeys}
The authentication via keys has been implemented with \ref{sec:DesignAuthViaKeys} in mind but with some alterations.\\
The first change was to store the public key in a plain text format, which was done out of convenience and can be changed in the future. Not storing the hashed public key doesn't pose any security threat, so fixing this deviation was deemed of low priority.\\
The second and last alteration was to have the structure of authorized keys on the server be stored exclusively in the \texttt{root} user's home directory. This is a sub-optimal approach, as his requires users to store their public keys in the superuser's directory, which can lead to mistakes. This will be fixed in the future.\\
To test the application, a test user was created and given a key pair which was created as follows using \cite{openssl}:
\setlistingBash
\begin{lstlisting}[caption={Generating a key pair for the client},label=lst:GenClientKeyPair]
openssl genpkey -out client.pem -algorithm rsa -pkeyopt rsa_keygen_bits:2048
openssl rsa -in client.pem -out client.pub -pubout
\end{lstlisting}

\section{User Data Querying}\label{sec:ImplUserDataQuerying}
Querying user data(see \ref{sec:DesignUserDataQuerying}) has been originally been implemented by using a private package that parsed the \texttt{passwd} file. In later stages, this has been corrected by switching to using \gls{CGo} and calling the \gls{Unix} \gls{API} routines.

\section{Login Accounting}\label{sec:ImplLoginAccounting}
The current implementation either outsources the post-login actions described in \ref{sec:DesignLoginAccounting} to \cite{login}(see \ref{sec:ImplAuthViaPAM}) or omits them completely, as is the case in \ref{sec:ImplAuthViaKeys}. The implementation of this feature is not part of the current project.

\section{Terminal Mode}\label{sec:ImplTerminalMode}
Setting the \gls{terminal} mode in \gls{Go} can be achieved with the functionality of the x-package \linebreak\texttt{golang.org/x/crypto/ssh/terminal}:
\setlistingGo
\begin{lstlisting}[caption={Setting the \gls{terminal} mode in \gls{Go}},label=lst:GoTermMode]
oldState, err := terminal.MakeRaw(0)
if err != nil {
	panic(err)
}
defer terminal.Restore(0, oldState)
\end{lstlisting}

\section{Pseudoterminal}\label{sec:ImplPseudoterminal}
\gls{Go} does have a wrapper for \glspl{pty} in an official package, but the code is inside an internal package, called \texttt{os/signal/internal/pty}, which uses \gls{CGo} to call the required \gls{API} routines described in \ref{sec:DesignPseudoterminal}:
\setlistingGo
\begin{lstlisting}[caption={\gls{Go}'s \gls{pty} wrapper},label=lst:GoPty]
// Open returns a master pty and the name of the linked slave tty.
func Open() (master *os.File, slave string, err error) {
	m, err := C.posix_openpt(C.O_RDWR)
	if err != nil {
		return nil, "", ptyError("posix_openpt", err)
	}
	if _, err := C.grantpt(m); err != nil {
		C.close(m)
		return nil, "", ptyError("grantpt", err)
	}
	if _, err := C.unlockpt(m); err != nil {
		C.close(m)
		return nil, "", ptyError("unlockpt", err)
	}
	slave = C.GoString(C.ptsname(m))
	return os.NewFile(uintptr(m), "pty-master"), slave, nil
}
\end{lstlisting}
For the project, this code has been altered to better fit the flow of the application.

\section{Problems}\label{sec:Problems}
\subsection{Forking}\label{ssec:Forking}
To handle new established connections, it was deemed important to \texttt{fork} the process, as this duplicated the current process' memory and returns the \gls{PID}: 0 for the child process and a number greater than 0 for the parent to have the \gls{PID} of the child.\\
In theory, this should have enabled the program to use \gls{Go}'s standard library capabilities to handle connections. However, there were several problems with this approach:

\subsubsection{Forking not supported}\label{sssec:ForkingNotSupported}
The \gls{Go} standard library does not support the classical \gls{C}-like forking. It only has a \texttt{syscall.\linebreak{}ForkExec} method, which is documented as:
\begin{quote}
Combination of fork and exec, careful to be thread safe.
\end{quote}
But since it uses \texttt{exec} as well, it is the same as calling arbitrary binaries/scripts with the \texttt{exec.Cmd} function.\\
However: \gls{Go} has a feature called \gls{CGo}, which allows programs to call and interact with native \gls{C}-routines. This opens up the possibility of using \texttt{fork(2)}.

\subsubsection{Forking breaks Go objects}\label{sssec:ForkingBreaksGoObjects}
Forking with the functionality of \gls{CGo} does not solve the problem either. The reason is that after forking there are two programs with a \texttt{net.Conn} object. This lead to both connection objects being corrupted and turning unusable. Therefore, it was necessary to abandon the clean solution of forking and instead creating a new executable that can handle new connections by its own.

\subsubsection{Sharing Data with Child}\label{sssec:SharingDataWithChild}
The question then was: How can a process instantiate a child process and hand over all resources to it necessary for handling the new connection?\\
Since they are 2 separate processes now, they don't share any memory anymore. Hence the parent has to give the child the information about the connection via arguments. The most direct way to deal with this is to use \glspl{fd}, which can be passed as integer arguments to the child.

\subsubsection{Go Connection Cannot Be Transferred}\label{sssec:GoConnectionCannotBeTransferred}
Getting a \texttt{net.Conn} interface from a \gls{fd} is supported in \gls{Go} via:
\setlistingGo
\begin{lstlisting}[caption={Getting a \texttt{net.Conn} interface from a \gls{fd}},label=lst:ConnFromFD]
fd := uintptr(0) // Dummy fd
conn, err := net.FileConn(os.NewFile(fd, "conn"))
if err != nil {
	panic(err.String())
}
\end{lstlisting}

Getting the \gls{fd} from a connection is also possible:
\setlistingGo
\begin{lstlisting}[caption={Getting the \gls{fd} from a \texttt{net.Conn} object},label=lst:FDFromConn]
file, err := conn.(*net.TCPConn).File()
if err != nil {
	panic(err.String())
}
fd := file.Fd()
\end{lstlisting}

However: Creating a connection with the high-level \gls{API} of \gls{Go} and handing over the \gls{fd} to the child to derive a \texttt{net.Conn} object from, fails.\\
This had some implications for the project: The listener on the server could not be created with the high-level like:
\setlistingGo
\begin{lstlisting}[caption={\gls{Go}'s high level \gls{API} for listener},label=lst:ListenForConn]
ln, err := net.Listen("tcp", ":8080")
if err != nil {
	// handle error
}
for {
	conn, err := ln.Accept()
	if err != nil {
		// handle error
	}
	go handleConnection(conn)
}
\end{lstlisting}

Instead the project had to rely on the low-level \gls{socket}. The \gls{x-package} \texttt{Unix} provides the necessary wrapper functions, which can be used instead.\\
The obvious drawback: Having to rely on a \gls{x-package} which is subject to change and not being able to use the higher-level methods which \textbf{are} part of the standard library.


\chapter{Results}\label{chp:Results}
\notes{\item (Zusammenfassung der Resultate)}

\chapter{Discussion And Prospects}\label{chp:DiscussionAndProspects}
\notes{
\item Bespricht die erzielten Ergebnisse bezüglich ihrer Erwartbarkeit, Aussagekraft und Relevanz
\item Interpretation und Validierung der Resultate
\item Rückblick auf Aufgabenstellung, erreicht bzw. nicht erreicht
\item Legt dar, wie an die Resultate (konkret vom Industriepartner oder weiteren Forschungsarbeiten; allgemein) angeschlossen werden kann; legt dar, welche Chancen die Resultate bieten
}

\chapter{Index}\label{chp:Index}
\bibliography{reference}\label{sec:Bibliography}
\newpage
\printglossary\label{sec:Glossary}
\newpage
\listoffigures\label{sec:ListOfFigures}
\newpage
\listoftables\label{sec:ListOfTables}
\newpage
\lstlistoflistings\label{sec:ListOfListings}
\newpage
\printglossary[title=SymbolGlossary,type=symbols]\label{sec:SymbolGlossary}
\newpage
\printglossary[title=Acronym Glossary,type=\acronymtype]\label{sec:AcronymGlossary}
\newpage
\printindex\label{sec:Index}

\appendix
\chapter{Appendix}\label{chp:Appendix}
\section{Project Management}\label{sec:ProjectManagement}
\notes{
\item Offizielle Aufgabenstellung, Projektauftrag
\item (Zeitplan) 
\item (Besprechungsprotokolle oder Journals)
}
\subsection{Official Statement of Tasks}\label{ssec:OfficialStatementOfTasks}
\includepdf[pages=-]{tasks.pdf}
\subsection{Project Plan}\label{ssec:ProjectPlan}
\includepdf[pages=-]{projectplan/Revised_project_plan.pdf}
\includepdf[pages=-,landscape=true]{zhawGanttDiagram.pdf}
\subsection{Meeting Minutes}\label{ssec:MeetingMinutes}
The meeting minutes have a disruption in style and execution beginning from the 6th meeting. Reason for this is because in the beginning of the project, Mr Schwarz was responsible for keeping the minutes, but he opted out of the project.
\includepdf[pages=-]{minutes/2nd_Meeting.pdf}
\includepdf[pages=-]{minutes/3rd_Meeting.pdf}
\includepdf[pages=-]{minutes/4th_Meeting.pdf}
\includepdf[pages=-]{minutes/5th_Meeting.pdf}
\includepdf[pages=-]{minutes/6th_Meeting.pdf}
\includepdf[pages=-]{minutes/7th_Meeting.pdf}
\includepdf[pages=-]{minutes/8th_Meeting.pdf}
\includepdf[pages=-]{minutes/9th_Meeting.pdf}
\includepdf[pages=-]{minutes/10th_Meeting.pdf}
\includepdf[pages=-]{minutes/11th_Meeting.pdf}

\section{Others}\label{sec:Others}
\notes{
\item CD mit dem vollständigen Bericht als pdf-File inklusive Film- und Fotomaterial
\item (Schaltpläne und Ablaufschemata)
\item (Spezifikationen u. Datenblätter der verwendeten Messgeräte und/oder Komponenten)
\item (Berechnungen, Messwerte, Simulationsresultate)
\item (Stoffdaten)
\item (Fehlerrechnungen mit Messunsicherheiten)
\item (Grafische Darstellungen, Fotos)
\item (Datenträger mit weiteren Daten(z. B. Software-Komponenten) inkl. Verzeichnis der auf diesem Datenträger abgelegten Dateien)
\item (Softwarecode)
}
\end{document}
