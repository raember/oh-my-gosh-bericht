%%	build-queue:
%%	
%%	¦¦¦ very first run. No .ist files yet
%%	¦¦	index, citation/bibliography or glossary changed
%%	¦	every change apart from the above mentioned. Double run for labels and toc.
%%	
%%	¦¦¦xelatex
%%	¦¦makeglossaries
%%	¦¦makeindex
%%	¦¦bibtex
%%	¦xelatex
%%	¦xelatex
%%	

\RequirePackage[l2tabu,orthodox]{nag}
\documentclass[10pt,a4paper,titlepage,twoside,english,final]{zhawreprt}

\include{packages}
\if false
\include{glossaryentries}
\fi

\include{zhawSetup}

\begin{document}

\maketitle

\chapter*{Abstract}\label{sec:Abstract}
\notes{\item Zusammenfassung}


\chapter*{Preface}\label{sec:Preface}
\notes{\item Stellt den persönlichen Bezug zur Arbeit dar und spricht Dank aus.}
The \gls{SSH} protocol \citep{rfc253,rfc6668,rfc8268,rfc8308,rfc8332} is a system that allows a user to log in on a remote machine and perform tasks on that remote machine via a \gls{CLI}. \gls{SSH} is widely known and used in everyday tasks. However: It is now over twelve years old in its current form. One of the problems with \gls{SSH} is its complexity, both in the initial phase when key material is exchanged, but also later, for example because the server must always decide whether to return a character that has been sent to it or not (echo).

The goal of this work is a radically simplified protocol, which in its functions is similar to \gls{SSH} (N.B. the similarity concerns the functions, not necessarily the protocol details). I develop the protocol, as well as a client and a server - all in \gls{Go}. I demonstrate that the software can replace \gls{SSH} by showing that it can handle several common use cases, among them:

\begin{itemize}
\item Interactive session
\item \texttt{Rsync} with my solution as transport protocol
\end{itemize}

This bachelor thesis was proposed by Dr. Stephan Neuhaus \citep{BA19_neut_03} and aroused my interest as it is a challenge in the domain of information security and will produce a palpable result.

On this note I would like to thank \gls{ZHAW} for granting me the opportunity to do my Bachelors thesis here and Dr. Stephan Neuhaus for helping me along the way of this Bachelors thesis.

\makedeclarationoforiginality

\tableofcontents

\chapter{Introduction}\label{chp:Introduction}
\section{Initial Position}\label{sec:InitialPosition}
\notes{
\item Nennt bestehende Arbeiten/Literatur zum Thema -> Literaturrecherche
\item Stand der Technik: Bisherige Lösungen des Problems und deren Grenzen
\item (Nennt kurz den Industriepartner und/oder weitere Kooperationspartner und dessen/deren Interesse am Thema Fragestellung)
}
There was no thesis done on this subject that could have been used as reference. There are however several software projects that deal with a similar problem.

\subsection{OpenSSH}\label{ssec:OpenSSH}
The most noteworthy work to mention is of course \gls{SSH} itself. \cite{openssh} is the name of the open source project which provides millions of administrators and developers with the ability to securely connect to a remote host. It replaces the up until then widely used protocols like \texttt{telnet}\ref{ssec:Telnet} and \texttt{rlogin}/\texttt{rsh}\ref{ssec:BerkeleyRCommands}.\\
\gls{SSH} uses \gls{TLS} to secure the communication channel between two peers and has earned itself a spot on the low end of the \gls{port} table: It occupies \gls{port} 22.\\
\gls{SSH}s features can be used very flexibly: After it builds up a secure connection between a client and a server, it can be used to remotely login and use a terminal on that machine.
It can also forward traffic on local ports to the remote host through the secure channel. This is also used by third party programs such as \texttt{rsync}.\\
When it comes to the log in procedure itself, \gls{SSH} allows for standard user log in using the \gls{API} of the \glspl{PAM}. Another feature is whitelisting of clients via their public keys, which barres intrusion via hijacked user-password-credentials.\\
After a secure connection could be established, there are multiple possibilities to use the opened channel. One is to forward the \gls{GUI} of a remote program to the client. Another one is to use this channel to tunnel more connections through it: For example can the traffic of an application which uses a specific \gls{port} be forwarded to the remote host. This can obscure and secure this traffic between the host and the server.

\subsection{Telnet}\label{ssec:Telnet}
Telnet\citep{rfc15,rfc854} is an old(1969) and deprecated communication protocol which doesn't feature any security. However, in other implementations, \gls{TELNETS} was proposed, which features encryption over the communication channel.\\
Telnet still has 23 as its very own \gls{port} assigned to it.
\subsubsection{Go-Telnet}
Go-Telnet\citep{gotelnet} is a \gls{TELNETS} supporting client-server-application which has been implemented in \gls{Go}.

\subsection{Berkeley r-commands}\label{ssec:BerkeleyRCommands}
The Berkley r-commands are a set of commands to do certain tasks on remote hosts. Those tasks are similar to their counterparts without a leading "\texttt{r}".
\begin{itemize}
\item \texttt{rlogin}\\
This command connects to the host and performs a \texttt{login} command, which includes authentication and if successful, spawning a user \gls{shell}.
\item \texttt{rsh}\\
\texttt{rsh} spawns a \gls{shell} without the log in process.
\item \texttt{rexec}\\
With this command, the user can log in to a remote machine and execute one command.
\item \texttt{rcp}\\
Using this command gives the user the ability to copy from and to a remote host.
\item \texttt{rwho}\\
This command tells the user what users are currently logged in on the remote machine.
\item \texttt{rstat}\\
\texttt{rstat} displays file system information from remote hosts.
\item \texttt{ruptime}\\
With this command, the user can see the uptime, number of logged in users and current work load of the remote machine.
\end{itemize}


\section{Task}\label{sec:Task}
\notes{
\item Formuliert das Ziel der Arbeit
\item Verweist auf die offizielle Aufgabenstellung des/der Dozierenden im Anhang
\item (Pflichtenheft, Spezifikation)
\item (Spezifiziert die Anforderungen an das Resultat der Arbeit)
\item (Übersicht über die Arbeit: stellt die folgenden Teile der Arbeit kurz vor)
\item (Angaben zum Zielpublikum: nennt das für die Arbeit vorausgesetzte Wissen)
\item (Terminologie: Definiert die in der Arbeit verwendeten Begriffe)
}
The official formulation of the tasks can be found in the appendix \ref{ssec:OfficialStatementOfTasks}.\\
The objective of this thesis is as follows:
\begin{itemize}
\item Design and implementation of a client-server protocol that can manage interactive sessions.
\item Design and implementation of a privilege-separation architecture on the server side that allows safe dropping of privileges once a client establishes a connection.
\end{itemize}

For a passing grade (4.0), the work must contain at least the following:
\begin{itemize}
\item In the thesis, an introduction to the problem and why the envisaged solution will solve it.
\item In the thesis, a survey of related work in the area.
\item In the thesis, a detailed design of the solution.
\item In the thesis, an evaluation of the performance of the implemented solution.
\item In the software, a privilege-separation architecture.
\end{itemize}

Incorporating the following components will improve the grade:
\begin{itemize}
\item In the related work section of the thesis, a comparison of all the related work with the envisaged solution, outlining why the envisaged solution is better.
\item In the thesis, a detailed analysis of the security of the solution, including possible attacks and defenses.
\item Use of TLS as the transport layer.
\item A proof-of-concept client that can handle interactive sessions.
\item A proof-of-concept client that works as a transport for \texttt{rsync}.
\end{itemize}

\vspace{1.5cm}
This thesis has been worded with technically literate readers in mind. However: For core concepts and special terms, a glossary can be found at \ref{sec:Glossary}. Used acronyms are listed in \ref{sec:AcronymGlossary}.

\chapter{Design}\label{chp:Design}
\section{Implementation Language}\label{sec:ImplementationLanguage}
In the beginning of the project, Dr Neuhaus suggested the use of \gls{Go} as a modern low-level language over interpreted languages for considerations of security. He emphasized that the use of other low-level languages(like \gls{C} or \gls{C++}) was permissible. In the end the project was implemented in \gls{Go} as suggested.\\
However, this lead to a few problems in the implementation process(See \ref{chp:Implementation}).

\section{Flow of Action}\label{sec:FlowOfAction}
To create a client-server protocol for remote log in and interactive sessions, a clear cut architecture is mandatory. The flow of a typical use case should look like this:

\begin{enumerate}
\item Server listens for incoming connection.
\item Client dials server.
\item Server spawns the users login shell and forwards all traffic between shell and Client.
\item Client uses shell on remote machine.
\item Client terminates session.
\item Host terminates.
\end{enumerate}

However, there are multiple security concerns to be satiated:

\begin{enumerate}
\item The Client must authenticate himself for a user of the remote system with the appropriate credentials.
\item The Server has to drop privilege after a successful login to prevent privilege escalation.
\item The Server has to spawn the login shell of the logged in user with the appropriate rights.
\end{enumerate}

Furthermore, the current design does not allow for multiple sessions to be run parallel. Therefore it was decided to spawn a new process to handle everything beginning after the connection has been established.\\
This lead to  the following general flow of actions:

\begin{enumerate}
\item Server listens for incoming connection.
\item Client dials server.
\item Server spawns a Host upon established connection.
\item Host sets up connection.
\item Host asks Client to authenticate himself.
\item Client authenticates himself.
\item Host drops privilege to logged in user.
\item Host spawns the users login shell with the same credentials and forwards all traffic between shell and Client.
\item Client uses shell on remote machine.
\item Client terminates session.
\item Host terminates.
\end{enumerate}

An earlier draft of the flow of actions was designed as a sequence diagram and looked like this:
\begin{figure}[ht]
\includegraphics[width=\textwidth]{SequenceDiagram}
\caption{Sequence diagram draft.}
\label{fig:SeqDiaOriginal}
\end{figure}

This design used a \gls{Request Broker}, which would put another master-slave-relationship between a \gls{shell} and the \gls{Request Broker}. This would have been an over-complication of the use of a \gls{shell}, which, if set correctly, already runs only with the rights of the corresponding user and its groups.



\chapter{Implementation}\label{chp:Implementation}
\notes{
\item (Beschreibt die Grundüberlegungen der realisierten Lösung (Konstruktion/Entwurf) und die Realisierung als Simulation, als Prototyp oder als Software-Komponente)
\item (Definiert Messgrössen, beschreibt Mess- oder Versuchsaufbau, beschreibt und dokumentiert Durchführung der Messungen/Versuche)
\item (Experimente)
\item (Lösungsweg)
\item (Modell)
\item (Tests und Validierung)
\item (Theoretische Herleitung der Lösung)
}
\section{Sequence Diagram}\label{sec:SequenceDiagram}
\begin{figure}[ht]
\includegraphics[width=\textwidth]{SequenceDiagramNew}
\caption{Sequence diagram of current implementation.}
\label{fig:SeqDiaCurrent}
\end{figure}

\section{Problems}\label{sec:Problems}
\subsection{Forking}\label{ssec:Forking}
To handle new established connections, it was deemed important to \texttt{fork} the process, as this duplicated the current process' memory and returns the \gls{PID}: 0 for the child process and a number greater than 0 for the parent to have the \gls{PID} of the child.\\
In theory, this should have enabled the program to use \gls{Go}s standard library capabilities to handle connections. However, there were several problems with this approach:

\subsubsection{Forking not supported}\label{sssec:ForkingNotSupported}
The \gls{Go} standard library does not support the classical \gls{C}-like forking. It only has a \texttt{syscall.ForkExec} method, which is documented as:
\begin{quote}
Combination of fork and exec, careful to be thread safe.
\end{quote}
But since it uses \texttt{exec} as well, it is the same as calling arbitrary binaries/scripts with the \texttt{exec.Cmd} function.\\
However: \gls{Go} has a feature called \gls{CGo}, which allows programs to call and interact with native \gls{C}-routines. This opens up the possibility of using \texttt{fork(2)}.

\subsubsection{Forking breaks Go objects}\label{sssec:ForkingBreaksGoObjects}
Forking with the functionality of \gls{CGo} does not solve the problem either. The reason is that after forking there are two programs with a \texttt{net.Conn} object. This lead to both connection objects being corrupted and turning unusable. Therefore, it was necessary to abandon the clean solution of forking and instead creating a new executable that can handle new connections by its own.

\subsubsection{Sharing Data with Child}\label{sssec:SharingDataWithChild}
The question then was: How can a process instantiate a child process and hand over all resources to it necessary for handling the new connection?\\
Since they are 2 separate processes now, they don't share any memory anymore. Hence the parent has to give the child the information about the connection via arguments. The most direct way to deal with this is to use \glspl{fd}, which can be passed as integer arguments to the child.

\subsubsection{Go Connection Cannot Be Transferred}\label{sssec:GoConnectionCannotBeTransferred}
Getting a \texttt{net.Conn} interface from a \gls{fd} is supported in \gls{Go} via:
\setlistingGo
\begin{lstlisting}[caption={Getting a \texttt{net.Conn} interface from a \gls{fd}},label=lst:ConnFromFD]
fd := uintptr(0) // Dummy fd
conn, err := net.FileConn(os.NewFile(fd, "conn"))
if err != nil {
	panic(err.String())
}
\end{lstlisting}

Getting the \gls{fd} from a connection is also possible:
\setlistingGo
\begin{lstlisting}[caption={Getting the \gls{fd} from a \texttt{net.Conn} object},label=lst:FDFromConn]
file, err := conn.(*net.TCPConn).File()
if err != nil {
	panic(err.String())
}
fd := file.Fd()
\end{lstlisting}

However: Creating a connection with the high-level \gls{API} of \gls{Go} and handing over the \gls{fd} to the child to derive a \texttt{net.Conn} object from it fails.\\
This had some implications for the project: The listener on the server could not be created with the high-level like:
\setlistingGo
\begin{lstlisting}[caption={\gls{Go}s high level \gls{API} for listener},label=lst:ListenForConn]
ln, err := net.Listen("tcp", ":8080")
if err != nil {
	// handle error
}
for {
	conn, err := ln.Accept()
	if err != nil {
		// handle error
	}
	go handleConnection(conn)
}
\end{lstlisting}

Instead the project had to rely on the low-level \gls{socket}. The \gls{x-package} \texttt{unix} provides the necessary wrapper functions, which can be used instead.\\
The obvious drawback: Having to rely on a \gls{x-package} which is subject to change and not being able to use the higher-level methods which \textbf{are} part of the standard library.



\chapter{Results}\label{chp:Results}
\notes{\item (Zusammenfassung der Resultate)}

\chapter{Discussion And Prospects}\label{chp:DiscussionAndProspects}
\notes{
\item Bespricht die erzielten Ergebnisse bezüglich ihrer Erwartbarkeit, Aussagekraft und Relevanz
\item Interpretation und Validierung der Resultate
\item Rückblick auf Aufgabenstellung, erreicht bzw. nicht erreicht
\item Legt dar, wie an die Resultate (konkret vom Industriepartner oder weiteren Forschungsarbeiten; allgemein) angeschlossen werden kann; legt dar, welche Chancen die Resultate bieten
}

\chapter{Index}\label{chp:Index}
\bibliography{reference}\label{sec:Bibliography}
\newpage
\printglossary\label{sec:Glossary}
\newpage
\listoffigures\label{sec:ListOfFigures}
\newpage
\listoftables\label{sec:ListOfTables}
\newpage
\lstlistoflistings\label{sec:ListOfListings}
\newpage
\printglossary[title=SymbolGlossary,type=symbols]\label{sec:SymbolGlossary}
\newpage
\printglossary[title=Acronym Glossary,type=\acronymtype]\label{sec:AcronymGlossary}
\newpage
\printindex\label{sec:Index}

\appendix
\chapter{Appendix}\label{chp:Appendix}
\section{Project Management}\label{sec:ProjectManagement}
\notes{
\item Offizielle Aufgabenstellung, Projektauftrag
\item (Zeitplan) 
\item (Besprechungsprotokolle oder Journals)
}
\subsection{Official Statement of Tasks}\label{ssec:OfficialStatementOfTasks}
\includepdf[pages=-]{tasks.pdf}
\subsection{Project Plan}\label{ssec:ProjectPlan}
\includepdf[pages=-]{projectplan/Revised_project_plan.pdf}
\includepdf[pages=-,landscape=true]{zhawGanttDiagram.pdf}
\subsection{Meeting Minutes}\label{ssec:MeetingMinutes}
The meeting minutes have a disruption in style and execution beginning from the 6th meeting. Reason for this is because in the beginning of the project, Mr Schwarz was responsible for keeping the minutes, but he opted out of the project.
\includepdf[pages=-]{minutes/2nd_Meeting.pdf}
\includepdf[pages=-]{minutes/3rd_Meeting.pdf}
\includepdf[pages=-]{minutes/4th_Meeting.pdf}
\includepdf[pages=-]{minutes/5th_Meeting.pdf}
\includepdf[pages=-]{minutes/6th_Meeting.pdf}
\includepdf[pages=-]{minutes/7th_Meeting.pdf}
\includepdf[pages=-]{minutes/8th_Meeting.pdf}

\section{Others}\label{sec:Others}
\notes{
\item CD mit dem vollständigen Bericht als pdf-File inklusive Film- und Fotomaterial
\item (Schaltpläne und Ablaufschemata)
\item (Spezifikationen u. Datenblätter der verwendeten Messgeräte und/oder Komponenten)
\item (Berechnungen, Messwerte, Simulationsresultate)
\item (Stoffdaten)
\item (Fehlerrechnungen mit Messunsicherheiten)
\item (Grafische Darstellungen, Fotos)
\item (Datenträger mit weiteren Daten(z. B. Software-Komponenten) inkl. Verzeichnis der auf diesem Datenträger abgelegten Dateien)
\item (Softwarecode)
}
\end{document}
